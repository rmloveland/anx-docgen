#+title: ANX-Docgen Design Notes
#+author: Rich Loveland
#+email: rloveland@appnexus.com

* Overview

  ANX-Docgen is an Emacs Lisp package that is designed to
  automatically create formatted documentation tables from the JSON
  returned by various AppNexus API services' `/meta' calls.

  As of today (Wed Dec 18 11:48:15 2013), it has a few weaknesses and
  limitations:

  - Generates fresh, blank tables only.  The writer still has to go in
    and add descriptions of the various fields by hand, which sucks.
    Here's an example of the current format for reference:

    #+BEGIN_QUOTE
    h2. Dimensions
    
    || Column || Type || Filter? || Description ||
    | month | date | Yes |  |
    | day | date | Yes |  |
    | hour | date | Yes |  |
    ...

    h2. Metrics
    
    || Column || Type || Formula || Description ||
    | imps | int |  |  |
    | clicks | int |  |  |
    | cost | money |  |  |
    ...
    #+END_QUOTE

  - The current output format is API-only.  (Although it's pretty
    close to what the Console documentation needs, and we can get most
    of the way there with some simple formatting changes.)

  - Can't currently be scripted; the user must interact with a
    running Emacs.

* Standard API Services
  
** Data Format

   You are given an array of JSON objects, which is converted into an
   array of Lisp association lists.

   For each alist, the following information is available:

   | Field    | Type             | Sort by? | Filter by? |
   |----------+------------------+----------+------------|
   | snapshot | array of objects | false    | false      |
   |          |                  |          |            |

   If the alist's `type' value is ``array of objects'', the =fields=
   key will also be available, which is itself an array of objects.

** Implementation

   As a first cut, we will implement a ``two-pass'' solution. We
   iterate over the array of objects, printing the =name=, =type=,
   =sort_by= and =filter_by= values into a tabular format.
   
   If the =type= is ``array of objects'', there should be a =fields=
   key. If this key exists, we will cons the name of the current
   object onto the array of objects in =fields=, and then push
   =fields= onto a stack.

   After the first pass, when we've printed out the initial table, we
   will then pop items off of the stack one by one, printing them out
   in a tabular format.

* Report Services

  There are several types of listings returned by the Report Service's
  `/meta' calls -- these examples are drawn from the Network Analytics
  report:

  - =time_intervals=: 1 line
  - =columns=: 124 lines
  - =filters=: 45 lines
  - =havings=: 20 lines
  - =label_fields=: 1 line
  - =time_granularity=: 1 line

  The report API documentation, by contrast, uses the following
  format:

  - Time Frame

    This just lists the items in the =time_intervals= field.

  - Dimensions

    These are everything the API calls the `columns', minus what it
    calls the `havings'.  An array of alists.

  - Metrics

    These are the items the API calls the `havings'.  Also an array of
    alists.

** Data Format

   You are given an association list with the following substructures:

   1. time_intervals (array of strings)

   2. havings (array of 1:alists)

   3. filters (array of 2:alists)

   4. retention_days (string)

   5. columns (array of 2:alists)

   6. time_granularity (string)

   The following dependencies exist:

   - `Havings' contains the ``Metrics'', which is a subset of the `columns'.

   - `Filters' is the subset of `columns' which can be filtered by.

   - `Columns' is a superset that includes `havings' and `filters'.
     
   Perhaps what we should do is create three hash tables,
   `havings-hash', `filters-hash' `column-types-hash'. As part of our
   pre-processing step, we'll add each item from `havings', `filters',
   and `columns' to their respective hash tables. The first two will
   add simple existence checks. For `columns', we want to store the
   `type' for later retrieval.

   Then, we iterate over `columns', checking each column against the
   `filters-hash' and `havings-hash'. If it's in `filters-hash', we output
   that in the documentation. If it's in `havings-hash', we add the
   `type' as the value to that hash key for the ``Metrics'' table.

   Thus we'll end up with headings for our documentation tables like
   so:

*** Dimensions

| Column | Type | Filter By? | Description |

*** Metrics

| Column | Type | Description |
* Next Steps: Generating Console Reporting Documentation

  In order to automatically prepare Console reporting documentation
  from the API's output, we need to do the following:

** Add `Time Frame' to the output

   This will make the format of Console reporting docs roughly
   similar to that of API report docs, e.g.:

   - Time Frame
   - Dimensions
   - Metrics
   - Example (not generated by this script)

** Store field descriptions in a separate file

   This would allow us to generate a new set of documentation very
   quickly.  Writers would add the descriptive text for each field to
   a JSON file attached to the wiki page, and then we'd regenerate the
   docs (manually, for now) upon update.

   We could have the high-level description (the first sentence or
   two) be the same for both Console and API documentation.  This
   could be followed by Console- or API-specific sentences which
   include links to further information (e.g., ``For more information
   about X, see Y.'')  It's even possible that X could remain the same
   for both document types, and only the Y would differ.

   The file format could be JSON, since people are familiar with that.
   We could start by just attaching the field descriptions to each
   page as a JSON file.

   Here's a possibility, expressed in outline form:

   - hour
     - base_description
     - further_info
       - console
       - api
   - day
     - base_description
     - further_info
       - console
       - api


   And here's a sample of the current (experimental) format:
   #+BEGIN_SRC json
     {
         "campaign_type": {
             "api_only": false,
             "further_info": {
                 "api": "For more information, see the {{labels}} field in the [api:Line Item Service] or the [api:Insertion Order Service].",
                 "console": "For more information, see [console:Reporting Labels], [console:Create an Insertion Order] or [console:Create a Line Item]."
             },
             "base_description": "The type of campaign which purchased the impression. This is a reporting label."
         }
     }
   #+END_SRC

** Pull metrics formulas directly from the DB (?)

   This is one that clients ask questions about.  (Note: See the email
   from Collette where he describes how to pull the formula from the
   DB.)  Is there a way to access this from Lisp?

   If this does happen, it will be much later.

* Work Items

** TODO Figure out how to slurp field definition info from existing documentation

   This won't be that easy in cases where the info spans multiple
   lines. Now that we're upgrading Confluence, it could get easier,
   since we'll only have access to a crap XML-ish format (which at
   least has a parser).

** TODO Modify anx-docgen.el to output a Lispy representation

   - [ ] Report APIs
   - [X] Regular APIs

** TODO Look into using esxml

   Rather than reinvent the wheel with your own format, research
   whether input/output to/from esxml will suffice.

** DONE Get everything under the 80-char limit!

** DONE Rewrite Lisp representation for standard reports as an alist

   See [[Report Services]].

